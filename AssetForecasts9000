from tkinter import Tk, Frame, Label, ttk, Button, Entry, StringVar, messagebox, Toplevel
from datetime import datetime, timedelta
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.ticker import FuncFormatter
import yfinance as yf
import requests
from textblob import TextBlob
import numpy as np
import pandas as pd
import math
from statistics import mean
import time
import json
import os


# Ticker Lists:
indices = ['☼SVIX☼', 'QQQ', 'DIA', 'SPY', 'COIN', 'HOOD']

#⊕
cryptos = [
'⊕⊕XRP☆', 
'⊕ADA☆', '⊕LTC☆', '⊕XLM☆',
'⊚AAVE☆', '⊚BTC☆', '⊚BCH☆', '⊚COMP☆', '⊚DOGE☆', '⊚ETC☆', '⊚LINK☆', '⊚SHIB☆', '⊚UNI☆', '⊚XTZ☆',
'⊖ARB☆', '⊖BONK☆',  '⊖ETH☆', '⊖SOL☆',
'⊖⊖PCAT☆', '⊖⊖PENG☆', '⊖⊖PNUT☆', '⊖⊖WIF☆']


stocks = ['ALLT', 'ASTS', 'CLOV', 'IONQ', 'KINS', 'NB', 'NUTX', 'OPFI', 'PLTR', 'QBTS', 'QUBT', 'RCAT', 'RGTI', 'RKLB', 'RPID', 'SKIL', 'UAMY', 'WGS']



upetfs = ['BITU', 'DPST', 'DRN', 'ETHU', 'FNGU', 'GUSH', 'JETU', 'LABU', 'SHNY', 'SOXL', 
'SPXL', 'SPYU', 'SVIX', 'TECL', 'TMF', 'TNA', 'TQQQ', 'UDOW', 'UPRO', 'WTIU', 'YINN' ]
dnetfs = ['DRIP', 'ETHD',  'DRV',  'FAZ', 'FNGD', 'LABD', 'SBIT', 'SDOW',  'SOXS', 'SPXS',
           'SPXU', 'SQQQ', 'SRTY',  'TMV', 'TZA', 'UVIX',  'YANG']
        
tckr01 = []



# Apply indentation
def indent_ticker(ticker, level):
    return f"{' ' * (level * 3)}{ticker}"
tckr0disp = [indent_ticker(t, 0) for t in indices] + \
            [indent_ticker(t, 2) for t in cryptos] + \
            [indent_ticker(t, 4) for t in stocks] + \
            [indent_ticker(t, 5) for t in upetfs] + \
            [indent_ticker(t, 6) for t in dnetfs] + \
            [indent_ticker(t, 0) for t in tckr01]
tckr0 = [t.replace('☼', '') for t in indices] + \
            [t.replace('⊕','').replace('⊚','').replace('⊖', '').replace('☆', '-USD').replace('ARB', 'ARB11841').replace('COMP', 'COMP5692').replace('PENG', 'PENGU34466').replace('PCAT', 'POPCAT28782').replace('UNI', 'UNI7083') for t in cryptos] + \
            [t for t in stocks] + \
            [t for t in upetfs] + \
            [t for t in dnetfs] + \
            [t for t in tckr01]


class DataManager:
    def __init__(self, cache_dir=None):
        self._cache = {}
        self._market_cache = {}
        self._realtime_cache = {}
        self._realtime_cache_time = {}
        self.cache_dir = cache_dir or os.path.join(os.getcwd(), '+MarketApps/stock_cache')
        os.makedirs(self.cache_dir, exist_ok=True)
        self._load_realtime_cache()
    def _get_cache_path(self, ticker, period, is_market=False):
        prefix = "market_" if is_market else ""
        safe_ticker = ticker.replace('-', '_').replace('.', '_')
        return os.path.join(self.cache_dir, f"{prefix}{safe_ticker}_{period}.csv")
    def _load_realtime_cache(self):
        cache_file = os.path.join(self.cache_dir, "realtime_cache.json")
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r') as f:
                    data = json.load(f)
                    self._realtime_cache = data.get('prices', {})
                    for ticker, ts_str in data.get('times', {}).items():
                        try:
                            self._realtime_cache_time[ticker] = datetime.fromisoformat(ts_str)
                        except: pass
            except Exception as e:
                print(f"Error loading realtime cache: {e}")
    def _save_realtime_cache(self):
        cache_file = os.path.join(self.cache_dir, "realtime_cache.json")
        try:
            times_dict = {t: dt.isoformat() for t, dt in self._realtime_cache_time.items()}
            with open(cache_file, 'w') as f:
                json.dump({'prices': self._realtime_cache, 'times': times_dict}, f)
        except Exception as e:
            print(f"Error saving realtime cache: {e}")
    def _fetch_yf_data(self, ticker, period):
        for attempt in range(3):
            try:
                stock = yf.Ticker(ticker)
                hist_data = stock.history(period=period) 
                try:
                    if price := stock.info.get('regularMarketPrice'):
                        self._realtime_cache[ticker] = price
                        self._realtime_cache_time[ticker] = datetime.now()
                        self._save_realtime_cache()
                except Exception: pass
                if not hist_data.empty:
                    cache_file = self._get_cache_path(ticker, period)
                    hist_data.to_csv(cache_file)
                return hist_data
            except Exception as e:
                if attempt < 2:  
                    wait_time = 5 ** attempt + 0.5
                    print(f"Retrying {ticker} in {wait_time}s... ({e})")
                    time.sleep(wait_time)
                else:
                    cache_file = self._get_cache_path(ticker, period)
                    if os.path.exists(cache_file):
                        return pd.read_csv(cache_file, index_col=0, parse_dates=True)
                    raise
    def get_stock_data(self, ticker, period, force_refresh=False):
        cache_key = (ticker, period)
        cache_file = self._get_cache_path(ticker, period) 
        if not force_refresh and cache_key in self._cache:
            return self._cache[cache_key]
        if not force_refresh and os.path.exists(cache_file):
            if time.time() - os.path.getmtime(cache_file) < 86400:  # 24h
                try:
                    data = pd.read_csv(cache_file, index_col=0, parse_dates=True)
                    self._cache[cache_key] = data
                    return data
                except Exception: pass
        try:
            data = self._fetch_yf_data(ticker, period)
            if not data.empty:  
                self._cache[cache_key] = data
                return data
        except Exception as e:
            print(f"Failed to fetch {ticker}: {e}")
            if os.path.exists(cache_file):
                try:
                    data = pd.read_csv(cache_file, index_col=0, parse_dates=True)
                    self._cache[cache_key] = data
                    return data
                except Exception: pass
        return None
    def get_realtime_price(self, ticker):
        current_time = datetime.now()
        if ticker in self._realtime_cache_time:
            if (current_time - self._realtime_cache_time[ticker]).total_seconds() < 600:
                return self._realtime_cache.get(ticker)
        try:
            price = yf.Ticker(ticker).info.get('regularMarketPrice')
            if price:
                self._realtime_cache[ticker] = price
                self._realtime_cache_time[ticker] = current_time
                self._save_realtime_cache()
                return price
        except Exception: pass
        return self._realtime_cache.get(ticker)
    def get_market_data(self, period, ticker, force_refresh=False):
        market_ticker = 'BTC-USD' if '-USD' in ticker else 'SPY'
        cache_key = (market_ticker, period)
        cache_file = self._get_cache_path(market_ticker, period, is_market=True)
        if not force_refresh and cache_key in self._market_cache:
            return self._market_cache[cache_key]
        if not force_refresh and os.path.exists(cache_file):
            if time.time() - os.path.getmtime(cache_file) < 86400:  # 24h
                try:
                    data = pd.read_csv(cache_file, index_col=0, parse_dates=True)
                    self._market_cache[cache_key] = data
                    return data
                except Exception: pass
        try:
            data = self._fetch_yf_data(market_ticker, period)
            if not data.empty:
                self._market_cache[cache_key] = data
                data.to_csv(cache_file)
                return data
        except Exception:
            if os.path.exists(cache_file):
                try:
                    data = pd.read_csv(cache_file, index_col=0, parse_dates=True)
                    self._market_cache[cache_key] = data
                    return data
                except Exception: pass
        return None
    def clear_cache(self, delete_files=False):
        self._cache.clear()
        self._market_cache.clear()
        self._realtime_cache.clear()
        self._realtime_cache_time.clear()
        if delete_files and os.path.exists(self.cache_dir):
            for f in os.listdir(self.cache_dir):
                try:
                    os.remove(os.path.join(self.cache_dir, f))
                except Exception: pass


#POPUP KEYBOARD (CLASS)
class PopupKeyboard:
    def __init__(self, master, entry_widget, simulator, monte_carlo=None):
        self.master = master
        self.entry_widget = entry_widget
        self.simulator = simulator
        self.monte_carlo = monte_carlo  # Store reference to MonteCarloSimulator
        self.keyboard_window = None
    # Add a setter method in case you need to set it later
    def set_monte_carlo(self, monte_carlo):
        self.monte_carlo = monte_carlo
    #Toggle Keyboard (Function)
    def toggle_keyboard(self):
        if self.keyboard_window is None or not self.keyboard_window.winfo_exists():
            self.show_keyboard()
        else:
            self.hide_keyboard()
    def show_keyboard(self):
        # Create new window
        self.keyboard_window = Toplevel(self.master)
        self.keyboard_window.title("Ticker Keyboard")
        # Simple resize prevention
        self.keyboard_window.resizable(0, 0)
        # Position the keyboard window near the input box
        x = self.master.winfo_x() + self.entry_widget.winfo_x() - 440
        y = self.master.winfo_y() + self.entry_widget.winfo_y() + 70
        self.keyboard_window.geometry(f"+{x}+{y}")
        # Create ticker dropdown frame
        dropdown_frame = Frame(self.keyboard_window)
        dropdown_frame.pack(pady=5, fill='x', padx=5)
        # Label for dropdown
        Label(dropdown_frame, text="Crypto Tickers:", font=('Helvetica', 8)).pack(side='left', padx=(40, 15))
        # Dropdown for tickers
        self.ticker_var = StringVar()
        self.ticker_dropdown = ttk.Combobox(dropdown_frame, textvariable=self.ticker_var, values=tckr0disp, width=15, state = 'readonly')
        self.ticker_dropdown.pack(side='left', padx=(15,15), pady = (0,0))
        # Button to add selected ticker
        Button(dropdown_frame, text="Add", command=self.add_selected_ticker, 
               font=('Helvetica', 7), bg='#f0f0f0').pack(side='left', padx=(25,0))
        # Define the keyboard layout
        keyboard_layout = [
            ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
            ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
            ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
            ['Z', 'X', 'C', 'V', 'B', 'N', 'M','-USD'],
            ['CLEAR','《', 'MOOD \n CHECK']]
        # Style configuration
        button_style = {'width': 1,'height': 2, 'font': ('Helvetica', 4),
            'relief': 'raised', 'bg': '#f0f0f0','activebackground': '#e0e0e0'}
        button_styleB = {'width': 4, 'height': 2, 'font': ('Romanitalics', 4),
            'relief': 'raised', 'bg': '#f0f0f0','activebackground': '#e0e0e0'}
        # Style keyboard buttons
        for row_idx, row in enumerate(keyboard_layout):
            frame = Frame(self.keyboard_window)
            frame.pack(pady=1)
            for key in row:
                if key == 'CLEAR':
                    btn = Button(frame, text=key, width=25, **{k:v for k,v in button_style.items() if k != 'width'}, command = self.clearentry)
                elif key == 'MOOD \n CHECK':
                    btn = Button(frame, text=key,  **button_styleB, command=self.moodcheck)
                elif key == '《':
                    btn = Button(frame, text=key,  **button_style, command=self.backspace)
                else:
                    btn = Button(frame, text=key, **button_style, 
                    command=lambda k=key: self.on_key_press(k))
                btn.pack(side='left', padx=1)
    def add_selected_ticker(self):
           selected_index = self.ticker_dropdown.current()
           selected_ticker = tckr0[selected_index]
           if selected_ticker:
               self.clearentry()  # Clear the entry first
               self.entry_widget.insert('end', selected_ticker) 
    def hide_keyboard(self):
        if self.keyboard_window:
            self.keyboard_window.destroy()
            self.keyboard_window = None
    def on_key_press(self, key):
        current_text = self.entry_widget.get()
        if key == '-USD':
            if current_text.strip():  # Only adds "-USD" if there's text
                if not current_text.strip().endswith('-USD'):
                    self.entry_widget.insert('end', '-USD')
        else:
            self.entry_widget.insert('end', key)    
    def clearentry(self):
            self.entry_widget.delete(0, 'end')
    def backspace(self):
        current_text = self.entry_widget.get()
        if current_text: # Removes whole "-USD" suffix
            if current_text.endswith('-USD'):
                self.entry_widget.delete(0, 'end')
                self.entry_widget.insert(0, current_text[:-4])
            else: # Removes last character
                self.entry_widget.delete(len(current_text)-1, 'end')
    def moodcheck(self):
           global news_sentiment
           asset = self.entry_widget.get()
           # Extract ticker before '-USD' and then remove any trailing numbers as well
           ticker = asset.split('-')[0]
           ticker = ''.join([c for c in ticker if not c.isdigit()])
           news_sentiment = get_crypto_news_sentiment(ticker, self.monte_carlo.arsi)
           if self.monte_carlo: self.monte_carlo.simulate_stock()
            
            
# MOOD CHECK #
news_sentiment = "---"
tickerN = ""
CRYPTO_POSITIVE =  ['adop', 'barg', 'big', 'bet', 'bett', 'best', 'blas', 'blow', 'boom', 'boos', 'brea', 'bull', 'buy', 'cons', 'ente', 'feas', 'gain', 'gear', 'good', 'grea', 'gree', 'grow', 'high', 'hodl', 'hold', 'hot', 'inno', 'impr', 'long', 'mome', 'moon', 'move', 'mult', 'part', 'port', 'prof', 'pump', 'rall', 'reve', 'rise', 'rock', 'succ', 'supp', 'surg', 'tren', 'unde', 'up', 'upda', 'upgr', 'upho', 'uptr', 'upwa', 'win', 'winn', 'won']
CRYPTO_NEGATIVE = ['arre', 'back', 'bad', 'ban', 'bank', 'bann', 'bear', 'bots', 'brea', 'bubb', 'burd', 'burs', 'bust', 'clow', 'coll', 'con', 'corr', 'crac', 'cras', 'debt', 'decl', 'defa', 'deli', 'desp', 'deva', 'dip', 'dive', 'doom', 'down', 'drop', 'dump', 'dupe', 'fail', 'fall', 'fear', 'fed', 'fine', 'flop', 'fomo', 'fool', 'frau', 'fud', 'gamb', 'hack', 'hike', 'hype', 'ille', 'impl', 'infl', 'inte', 'inso', 'laun', 'laws', 'leav', 'left', 'lega', 'liqu', 'loan', 'lose', 'losi', 'loss', 'lost', 'lows', 'lowe', 'mani', 'over', 'pani', 'pena', 'ponz', 'pyra', 'rate',  'rece', 'red', 'regu', 'resi', 'rest', 'risk', 'rugp', 'scam', 'sell', 'shor', 'shut', 'slow', 'stol', 'susp', 'swan', 'tari', 'tarr', 'unst', 'vuln', 'wors']

def enhanced_crypto_sentiment(text, arsi):
    """Calculate weighted sentiment on a -10 to 10 scale"""
    # Get base sentiment from TextBlob
    blob = TextBlob(text)
    base_sentiment = blob.sentiment.polarity  # Already -1 to 1 scale
    # Count crypto-specific terms
    text_lower = text.lower()
    # Split text into words and truncate to first 4 letters
    words = text_lower.split()
    truncated_words = [letters[:4] for letters in words if len(letters) >= 4]
    trunc_text = " ".join(truncated_words)
    positive_count = sum(1 for term in CRYPTO_POSITIVE if term in trunc_text)
    negative_count = sum(1 for term in CRYPTO_NEGATIVE if term in trunc_text)
   # bad news weight
    badnews_weight = 0.666 + arsi
    normalized_term_difference = (positive_count - badnews_weight*negative_count)/(positive_count + badnews_weight*negative_count + 0.10)
    crypto_sentiment = normalized_term_difference
    # Apply your desired weighting (% regular, % crypto)
    regular_weight = 36
    crypto_weight = 64
    # Combined weighted sentiment on -1 to 1 scale
    combined_sentiment = ((base_sentiment * regular_weight) + (crypto_sentiment * crypto_weight))/(regular_weight + crypto_weight)
    # Scale to -10 to 10 for final output
    final_score = combined_sentiment * 10
    return final_score  # Just return the single score value
def get_crypto_news_sentiment(coin_symbol, arsi):
    """Returns a single sentiment score from -10 to 10"""
    # CryptoCompare News API endpoint
    url = f"https://min-api.cryptocompare.com/data/v2/news/?categories={coin_symbol}&excludeCategories=Sponsored"
    try:
        response = requests.get(url, timeout=2000)
        news_data = response.json()
        if "Data" in news_data and news_data["Data"]:
            articles = news_data["Data"]
            # Calculate sentiment for each article
            scores = []
            for article in articles:
                title = article["title"]
                body = article.get("body", "")
                content = title + " " + body
                score = enhanced_crypto_sentiment(content, arsi)
                scores.append(score)
            # Calculate average sentiment and direction
            avg_sentiment = sum(scores) / len(scores)
            sentiment_direction = 'Mudhorsing'
            if avg_sentiment > 1.5: sentiment_direction = 'Gallophorsing'
            elif avg_sentiment < -0.25: sentiment_direction = 'Lemminghorsing'
            str_sentiment = f"{avg_sentiment:.1f}/10"
            return {
                'mood': str_sentiment,
                'opinion': sentiment_direction}
        else:
            return {"error": "Failed to fetch news"}
    except Exception as e:
        return {"error": f"Error: {str(e)}"}



#Format Prices (Function)
def format_value(value):
       try: # Handle string input
             if isinstance(value, str):
                  value = float(value.replace('$', '')) 
            # Define metric prefixes
             prefixes = [
                    (1e12, "T"), (1e9, "G"), (1e6, "M"), (1e3, "K"),
                    (1e0, " "), (1e-2, "c"), (1e-3, "m"), (1e-6, "μ"), (1e-9, "n")]
            # Find appropriate prefix
             for scale, prefix in prefixes:
                  if abs(value) >= scale:
                        scaled_value = value / scale
                        # Format to 3 significant figures
                        if scaled_value >= 100:
                              formatted = f"{scaled_value:.0f}"
                        elif scaled_value >= 10:
                              formatted = f"{scaled_value:.1f}"
                        else:
                              formatted = f"{scaled_value:.2f}"
                        # Only add prefix if it's not empty
                        prefix_str = f"{prefix}" if prefix else ""
                        return f"{formatted}{prefix_str}"
             return " –––"
       except (ValueError, AttributeError):
             return str(value)



#MONTE CARLO SIMULATION (CLASS)
class MonteCarloSimulator:
    def __init__(self, master):
       #InitializieDataManager
        self.data_manager = DataManager()
        self.last_simulation_data = None
        self.last_hist_data = None
       
       #MasterSetup
        self.master = master
        self.master.title("AssetForecasts9000")
        self.master.geometry("1075x850+100+100")
       #Master Grid
        self.mstr_grid = Frame(master, width=1075, height=2000)
        self.mstr_grid.grid()
        for i in range(40):
            self.mstr_grid.grid_rowconfigure(i, weight=1, minsize=21) 
        for i in range(13):
            self.mstr_grid.grid_columnconfigure(i, weight=1, minsize=80)
        self.mstr_grid.grid_propagate(False)
        #Form Title
        self.lbl_title = Label(self.mstr_grid, text="      ◇Asset♧Forecasts♡9000♤", font=('Roman', 12)) 
        self.lbl_title.grid(row=0, column=0, columnspan=12, sticky='news')
        
       #Container Grid
        self.box_grid = Frame(self.mstr_grid, width=1000, height=1140) 
        self.box_grid.grid(row=1, column=0, columnspan=13, rowspan=23, sticky='nsew') 
        self.box_grid.grid_propagate(False)
        self.box_grid.grid_rowconfigure(0, weight=1)
        self.box_grid.grid_columnconfigure(0, weight=1)
        
        # Forecast Period (Static Label)
        self.lbl_time_prd = Label(self.mstr_grid, text="Forecast Period", font=('Helvetica', 6)) 
        self.lbl_time_prd.grid(row=26, column=1, columnspan=3, sticky='s') 
        self.prd_select = StringVar()
        #Time Period (Selection Box)
        self.period_ddbox = ttk.Combobox(self.mstr_grid, width=15, justify = 'center', textvariable=self.prd_select, state='readonly')
        self.period_ddbox['values'] = ('1.5 WK', '1 MO', '2 MO', '4 MO', '1.5 YR')
        self.period_ddbox.grid(row=27, column=1, columnspan=3, sticky='n')
        self.period_ddbox.current(1)

        # Ticker (Static Label)
        self.lbl_ticker = Label(self.mstr_grid, text="Ticker", font=('Helvetica', 6)) 
        self.lbl_ticker.grid(row=24, column=5, columnspan=3, sticky='s')
        # Ticker (Entry Box)
        self.entry_stock = Entry(self.mstr_grid, justify='center', font=('Helvetica', 7))
        self.entry_stock.grid(row=25, column=5, columnspan=3, sticky='news')
        
        # Initialize the keyboard
        self.keyboard = PopupKeyboard(self.master, self.entry_stock, self, self)
        
        # Keyboard Button
        self.btn_keyboard = Button(self.mstr_grid, text="⧇⧇⧇⧇\n⧇⧇⧇⧇⧇", 
            font=('Helvetica', 7), command=self.keyboard.toggle_keyboard)
        self.btn_keyboard.grid(row=26, column=5, rowspan=3, columnspan=2, sticky='snwe')

        #REVERT BACK (Static Display Label)
        self.lbl_backtrack = Label(self.mstr_grid, text="Revert:", font=('Helvetica', 6)) 
        self.lbl_backtrack.grid(row=26, column=9, columnspan=3, sticky='ews')
        self.backtrack_days = StringVar(value="0")
        #REVERT BACK (Dynamic Display Label)
        self.lbl_backtrack_days = Label(self.mstr_grid, textvariable=self.backtrack_days, font=('Helvetica', 7)) 
        self.lbl_backtrack_days.grid(row=27, column=9, columnspan=3, sticky='news')

       #Backtracking (Buttons)
       #Back Button (-9 days)
        self.btn_backtrack_minus9 = Button(self.mstr_grid, text="- - -", 
            font=('Helvetica', 7),  command=self.backtrack_minus9) 
        self.btn_backtrack_minus9.grid(row=27, column=7, columnspan = 1, sticky='n')
       #Back Button (-3 days)
        self.btn_backtrack_minus3 = Button(self.mstr_grid, text="- -", 
            font=('Helvetica', 7), command=self.backtrack_minus3) 
        self.btn_backtrack_minus3.grid(row=27, column=8, sticky='n')
        #Back Button (-1 days)
        self.btn_backtrack_minus1 = Button(self.mstr_grid, text="-", 
            font=('Helvetica', 7), command=self.backtrack_minus) 
        self.btn_backtrack_minus1.grid(row=27, column=9, sticky='n')
       #Forth Button (+1 days)
        self.btn_backtrack_plus = Button(self.mstr_grid, text="+", 
            font=('Helvetica', 7), command=self.backtrack_plus) 
        self.btn_backtrack_plus.grid(row=27, column=11, sticky='n')
        #Forth Button (+26 days)
        self.btn_backtrack_plus18 = Button(self.mstr_grid, text="+ +", 
            font=('Helvetica', 7), command=self.backtrack_plus18) 
        self.btn_backtrack_plus18.grid(row=27, column=12, sticky='n')
        
        #Simulation (Button)
        self.btn_simulate = Button(self.mstr_grid, text="S I M U L A T E", 
            font=('Helvetica', 6), command=self.simulate_stock) 
        self.btn_simulate.grid(row=25, column=8, columnspan=5, rowspan = 1, sticky='new') 
        
        #Indicator Labels (Dynamic Labels)
        self.lbl_indicators1 = Label(self.mstr_grid, text="Indicators: - ", font=('Helvetica', 5)) 
        self.lbl_indicators1.grid(row=30, column=0, columnspan=13, rowspan=8, sticky='ew')
        self.lbl_indicators2 = Label(self.mstr_grid, text="Indicators: - ", font=('Helvetica', 6)) 
        self.lbl_indicators2.grid(row=38, column=0, columnspan=13, rowspan=2, sticky='ew')
        
        #Clock Label
        self.friclevel = 0
        self.clockcolor = 'lightgray'
        self.clock_label = Label(self.mstr_grid, font=('Roman', 8), bg = self.clockcolor)
        self.clock_label.grid(row=24, column=0, rowspan = 2, columnspan=5, sticky='news')
        self.update_clock()
        
   #Market Friction (Function)
    def determine_friction(self):
            mrsi = self.mrsi
            arn = self.aroon_osc[-1]
            arsi = self.arsi
            if (mrsi > 0.62) or (arsi > 0.62) or (arn < -75) or (arn > 75) or (self.ssind == "Drop ￬") or (self.fmaxday == 0): self.friclevel = 5
            elif (mrsi > 0.53) or (arsi > 0.53) or (arn < -60) or (arn > 65) or (self.ssind == "Dip ⭞"): self.friclevel = 4
            elif (mrsi > 0.35) or (arsi > 0.35): self.friclevel = 3
            elif (mrsi > 0.24) or (arsi > 0.24): self.friclevel = 2
            else: self.friclevel = 1
   #Update Clock Function
    def update_clock(self):
            current_time = time.strftime(' %I:%M:%S %p MST \n   %m-%d-%Y')
            if self.friclevel == 5: self.clockcolor = '#E05555'; markmove = f'  ￬ {self.whaleprox}'
            elif self.friclevel == 4: self.clockcolor = 'orange'; markmove = f' ⭞ {self.whaleprox}'
            elif self.friclevel == 3: self.clockcolor = 'lightblue' ; markmove = f'  ↕ {self.whaleprox}'
            elif self.friclevel == 2: self.clockcolor = 'lightgreen'; markmove = f' ↑ {self.whaleprox}'
            elif self.friclevel == 1: self.clockcolor = 'green'; markmove = f'  ⇈ {self.whaleprox}'
            else: self.clockcolor = 'lightgray'; markmove = f''
            self.clock_label.config(text=f"{current_time}  {markmove}", bg = self.clockcolor)
            self.master.after(1000, self.update_clock)
    
    
    #Backtrack Buttons (Functions)
    def backtrack_minus9(self):
        current_days = int(self.backtrack_days.get())
        self.backtrack_days.set(str(current_days + 9))
        if self.last_hist_data is not None: self.simulate_stock()
    def backtrack_minus3(self):
        current_days = int(self.backtrack_days.get())
        self.backtrack_days.set(str(current_days + 3))
        if self.last_hist_data is not None: self.simulate_stock()
    def backtrack_minus(self):
        current_days = int(self.backtrack_days.get())
        self.backtrack_days.set(str(current_days + 1))
        if self.last_hist_data is not None: self.simulate_stock()
    def backtrack_plus(self): 
        current_days = int(self.backtrack_days.get())
        if current_days > 0: 
            self.backtrack_days.set(str(current_days - 1))
            if self.last_hist_data is not None: self.simulate_stock()
    def backtrack_plus18(self):
       current_days = int(self.backtrack_days.get())
       if current_days > 18:
           self.backtrack_days.set(str(current_days - 18))
           if self.last_hist_data is not None: self.simulate_stock()
       else: 
           self.backtrack_days.set(str(0))
           if self.last_hist_data is not None: self.simulate_stock()
    
    #Clear Box Grid (Function)
    def clear_box_grid(self):
        for widget in self.box_grid.winfo_children():
            widget.destroy()
    #Fetch Ticker Data  (Function)
    def fetch_stock_data(self, ticker, period):
        """Fetches data using the DataManager"""
        period_map = {'1.5 WK': '6mo', '1 MO': '6mo','2 MO': '6mo', '4 MO': '1y', '1.5 YR': '5y'}
        data = self.data_manager.get_stock_data(ticker, period_map[period])
        return data
    #Run Simulation (Function)
    def simulate_stock(self):
            global news_sentiment
            """Main simulation function with optimized data handling"""
            ticker = self.entry_stock.get().upper()
            if tickerN != ticker: news_sentiment = "---"
            period = self.prd_select.get()
            backtrack_days = int(self.backtrack_days.get())
            if not ticker:
                 messagebox.showwarning("Warning", "Please enter a stock ticker")
                 return  
           # Fetch data using DataManager
            hist_data = self.fetch_stock_data(ticker, period)
            if hist_data is None: return
           # Store reference and calculate all needed values
            self.last_hist_data = hist_data
           # Run simulations with the same data
            self.plot_monte_carlo(hist_data, ticker, backtrack_days)
            self.update_indicator_label(hist_data)
    
    
   #All Calculations (Function)
    def allcalculations(self, data, backtrack_days=0):
         try:  # Guard against empty or None data
                global tickerN
                if data is None or len(data) == 0:
                     print("Error: No data provided to allcalculations")
                     return None
                ticker = self.entry_stock.get().upper()
                tickerN = ticker
                # Ensure we have numeric values
                def safe_float(value):
                     try:
                              return float(value)
                     except (ValueError, TypeError):
                              return 0.0
                DailyPrices = self.avghistdata1
                # Compute key price points as scalar values
                high = safe_float(data['High'].iloc[-1])
                low = safe_float(data['Low'].iloc[-1])
                close = safe_float(DailyPrices.iloc[-1])
                # Determine current price
                current_price = None
                if backtrack_days == 0:  current_price = self.data_manager.get_realtime_price(ticker)
                # If real-time price is not available, calculate from historical data
                if not current_price: current_price = DailyPrices.iloc[-(backtrack_days+1)]
                # Asset Specific Variables
                is_crypto = '-USD' in ticker
                if is_crypto:  # Cryptos
                    market_ticker = 'BTC-USD'
                    wndwA = [31, 24, 17, 10, 3] #c.meansA
                    wndwB = [32, 25, 18, 11, 4] #c.meansB
                else: # Stocks
                    market_ticker = 'SPY'
                    wndwA = [23, 18, 13, 8, 3] #s.meansA
                    wndwB = [22, 17, 12, 7, 2] #s.meansB
                 # Set Market Data
                market_data = self.data_manager.get_market_data('3Mo', market_ticker)
                if market_data is None:
                       print(f"Error: Could not fetch market data for {market_ticker}")
                       return None
                if backtrack_days > 0: market_data = market_data.iloc[:-(backtrack_days+1)] 
                # Means and PercMnVal
                MnValA = []
                PercMnValA = []
                for i in range(5): 
                      mn_a = DailyPrices.tail(wndwA[i]).mean()
                      mn_b = DailyPrices.tail(wndwB[i]).mean()
                      mnVal = (mn_a+mn_b)*(1/2)
                      MnValA.append(mnVal)
                      PercMnValA.append((current_price/mnVal)*100-100)
                # MACD Calculations -
                self.longaroon, self.hsperc, self.hsbias = self.hotstreakpercbias(data)
                multi_analysis = self.compute_multi_ma_macd(data, is_crypto, PercMnValA)
                if multi_analysis:
                    moving_averages = multi_analysis['moving_averages']
                    macds = multi_analysis['macds']
                # RSI Values  -
                for d in range(0,2):
                      if d == 0: DailyPrice = DailyPrices
                      else: DailyPrice = market_data['Close']
                      rsi = self.calculate_rsi(DailyPrice, is_crypto)[-1]/100
                      if d == 0: arsi = rsi
                      elif d == 1: mrsi = rsi
               # Bollinger Bands -
                bperiod = 14
                bmultiplier = 2.0
                envdays = len(DailyPrices)-1
                bolldays = 4
                dBollinger = [0]*bolldays
                self.UpperB = [0]*envdays
                self.LowerB = [0]*envdays
                for j in range(0, envdays):
                      dataJ = DailyPrices.iloc[:-(j+1)]
                      if j == 0:  Jcurrent = current_price
                      else: Jcurrent = dataJ.iloc[-1]
                      rolling_mean = safe_float(dataJ.tail(bperiod).mean())
                      rolling_std = safe_float(dataJ.tail(bperiod).std())
                      Lower_Band = rolling_mean - (bmultiplier * rolling_std)
                      if np.isnan(Lower_Band): self.LowerB[envdays - (j+1)] = rolling_mean*0.90
                      elif Lower_Band < 0: self.LowerB[envdays - (j+1)] = 0
                      else: self.LowerB[envdays - (j+1)] = Lower_Band
                      Upper_Band = rolling_mean + (bmultiplier * rolling_std)
                      self.UpperB[envdays - (j+1)] = rolling_mean*1.10 if np.isnan(Upper_Band) else Upper_Band
                      if j < bolldays: dBollinger[bolldays-(j+1)] = 5*(Jcurrent - Lower_Band) / (Upper_Band - Lower_Band)
                self.ENVmax = max(self.UpperB)
                self.ENVmin = min(self.LowerB)
                mnEnv = math.ceil(mean(dBollinger[:-2]))
                if mnEnv <= 0: mnEnv = mnEnv - 1
                curEnv = math.ceil(dBollinger[-1])
                envSprd = max(mean(dBollinger), 3) - min(mean(dBollinger), 3)
                if curEnv <= 0: curEnv = curEnv - 1
                # abroons -
                hist_chain = 250
                decay1 = 0.99995
                decay2 = 1 - (2-self.hsbias/100)*self.Qcrossover*0.000625
                decay = (decay1 + envSprd*decay2)/(1+envSprd)
                aroons, broon, broonmatrix = self.calculate_abroons(data, hist_chain, decay)
                disp_aroons = aroons[-6:]
                # Pivots and Supports -
                pivotA = (high + low + close) / 3
                pivotB = (pivotA * 2) - high
                pivotC = pivotA - (high - low)
                pivhigh = 2*pivotA - (pivotB + pivotC)/2
                env_width = safe_float((self.UpperB[-1] - self.LowerB[-1]))
                rf = 1/5
                supports = []
                fib_ratios = [i*rf for i in range(-14, 20)]
                for fib_ratio in fib_ratios:
                      support = self.UpperB[-1] -  fib_ratio * env_width
                      supports.append(support)
                spprts = sorted(supports, reverse=True)
               #  Monte Carlo Sim Dynamic Forecast -
                num_simulations = 3000
                simulations = np.zeros((num_simulations, self.simdays + 1))
                simulations[:, 0] = current_price
                # Check Boost Conditions for the Appropriate Forecasting Model
                # (1) Bonus Market ==> RSI Forecast
                if (aroons[-1] > -17) and (aroons[-1] > aroons[-2]) and (self.forecast_period in ['1.5 WK', '1 MO']):
                   	self.fc = "|| ℛ"
                   	returns = DailyPrices.pct_change().dropna()
                   	historical_prices = DailyPrices
                   	mean_return = returns.mean()
                   	std_return = returns.std()
                   	rsi_paths = np.zeros((num_simulations, self.simdays + 1))
                   	rsi_paths[:, 0] = 100*arsi
                   	for sim in range(num_simulations):
                               price_history = np.concatenate([historical_prices, [current_price]])
                               for day in range(1, self.simdays+1):
                                       current_rsi = rsi_paths[sim, day-1]
                                       rsi_volatility = 1.0 + (current_rsi - 50) / 100  
                                       rsi_return_adjustment = (50 - current_rsi) / 500
                                       daily_return = np.random.normal(
                                                 mean_return + rsi_return_adjustment, 
                                                 std_return * rsi_volatility) 
                                       simulations[sim, day] = simulations[sim, day-1] * (1 + daily_return)
                                       price_history = np.append(price_history[1:], simulations[sim, day])
                                       rsi_paths[sim, day] = self.calculate_rsi(price_history, is_crypto)[-1]
                else: # (2) Classic Market ==> Abroon Forecast
                        self.fc = "Ȃ ||"
                        for sim in range(num_simulations):
                               # Generate extended b-roon chain with associated return characteristics
                                broon_chain, mean_returns, std_returns = self.ext_broons(broon, broonmatrix, self.simdays)
                                for day in range(1, self.simdays+1):
                                        # Use the transition-specific return and volatility
                                        expected_return = mean_returns[day-1]
                                        return_volatility = std_returns[day-1]
                                        # Generate return using the specific parameters for this transition
                                        daily_return = np.random.normal(expected_return, return_volatility)
                                        simulations[sim, day] = simulations[sim, day-1] * (1 + daily_return)
                #Stored Results:
                self.current_price = current_price
                self.iscrypto = is_crypto
                self.MnValA = MnValA
                self.PercMnValA = PercMnValA
                self.dBollinger = dBollinger
                self.curEnv = curEnv
                self.mnEnv = mnEnv
                self.arsi = arsi
                self.mrsi = mrsi
                self.moving_averages = moving_averages
                self.macds = macds
                self.aroon_osc = disp_aroons
                self.pivots = [pivotA, pivotB, pivotC]
                self.pivhigh = pivhigh
                self.spprts = spprts
                self.simulations = simulations
                return True  #Success
         except Exception as e:
                 print(f"Detailed Calculation error: {e}")
                 import traceback
                 traceback.print_exc()
                 return None
       
                  
    #Historical abroon chain and broonmatrix (calculation)
    def calculate_abroons(self, data, chain_length, decay_factor=0.99):
           # bAroons calculation
           aroons = [0]*chain_length
           broons = [0]*chain_length
           # Store the actual returns and their weights for each transition
           returns_data = []
           for AO in range(chain_length):
                  dataA = data.iloc[:-AO] if AO > 0 else data
                   # Check if dataA is empty or too small for processing
                  if len(dataA) < 9:  # 9 is the largest aroon_period we use
                        # Fill in defaults for this position in the chain
                        aroons[(chain_length-1)-AO] = 0
                        broons[(chain_length-1)-AO] = 0
                        continue
                  aroon_periods = [5, 6, 6, 7, 8, 9]
                  aroon_oscillators = [0]*6
                  for j in range(6):      
                       aroon_period = aroon_periods[j]
                       mids = (3*dataA['Open'].tail(aroon_period)+4*dataA['Close'].tail(aroon_period))*(1/7)
                       highs = dataA['High'].tail(aroon_period)
                       lows = dataA['Low'].tail(aroon_period)
                       geohighs =(highs*mids)**(1/2)
                       geolows = lows + (mids - (mids*lows)**(1/2))
                       high_series = geohighs
                       low_series = geolows
                      # Check if series are empty before calling argmax/argmin
                       if len(high_series) == 0 or len(low_series) == 0:
                           aroon_oscillators[j] = 0  # Default value when data is missing
                           continue
                       periods_since_high = aroon_period - high_series.values.argmax() - 1
                       periods_since_low = aroon_period - low_series.values.argmin() - 1
                       aroon_up = ((aroon_period - periods_since_high) / aroon_period)*100
                       aroon_down = ((aroon_period - periods_since_low) / aroon_period)*100
                       aroon_oscillators[j] = (aroon_up - aroon_down)
                  aroons[(chain_length-1)-AO] = mean(aroon_oscillators)
                  broons[(chain_length-1)-AO] = np.round(2*mean(aroon_oscillators)/100)
                  # Store return for this period if not the last element
                  if AO < chain_length-1 and AO > 0:
                       # Check if we have enough data to calculate returns
                       if len(dataA) > 0 and AO > 0 and len(data) > AO-1:
                            # Calculate the return from this point to next point
                            current_price = dataA['Close'].iloc[-1]
                            next_price = data.iloc[-(AO-1)]['Close']
                            period_return = (next_price / current_price) - 1
                           # Calculate time weight based on recency (newer = higher weight)
                            time_weight = decay_factor ** (AO-1)
                            returns_data.append(
                                   (broons[(chain_length-1)-AO], 
                                     broons[(chain_length-1)-(AO-1)], 
                                     period_return, time_weight))
           broon = broons[-1]
           # Initialize matrices for weighted counts, weighted return sums, and weighted squared returns
           weighted_counts = np.zeros((5, 5))
           weighted_returns_sum = np.zeros((5, 5))
           weighted_returns_squared_sum = np.zeros((5, 5))
           # Process the returns data to build our enhanced matrix
           for current_broon, next_broon, ret, weight in returns_data:
                 current_idx = int(current_broon) + 2  # Convert from -2..2 to 0..4
                 next_idx = int(next_broon) + 2
                 if 0 <= current_idx < 5 and 0 <= next_idx < 5:
                      weighted_counts[current_idx][next_idx] += weight
                      weighted_returns_sum[current_idx][next_idx] += ret * weight
                      weighted_returns_squared_sum[current_idx][next_idx] += (ret**2) * weight
           # Create the enhanced broonmatrix with (probability, avg_return, std_return)
           broonmatrix = np.zeros((5, 5), dtype=object)
           for i in range(5):
                row_total = np.sum(weighted_counts[i])
                for j in range(5):
                      if weighted_counts[i][j] > 0:
                             # Calculate weighted transition probability
                             probability = weighted_counts[i][j] / max(1e-10, row_total) 
                             # Calculate weighted average return
                             avg_return = weighted_returns_sum[i][j] / weighted_counts[i][j]
                            # Calculate weighted return standard deviation
                             variance = (weighted_returns_squared_sum[i][j] / weighted_counts[i][j]) - (avg_return**2)
                             std_return = np.sqrt(max(0, variance))  # Ensure non-negative
                             # Store all three values
                             broonmatrix[i][j] = (probability, avg_return, std_return)
                      else:
                             # Default values when no transitions observed
                              broonmatrix[i][j] = (0, 0, 0)
           return aroons, broon, broonmatrix
    #Extends broonchain and stats into future future
    def ext_broons(self, b_roon, broonmatrix, ext_lngth=30):
           extended = [b_roon]
           returns = []
           volatilities = []
           for _ in range(ext_lngth):
                 current = int(extended[-1])
                 curr_idx = current + 2  # Convert from -2..2 to 0..4
                 if 0 <= curr_idx < 5:
                        # Extract just the probabilities for next state selection
                        probs = np.array([broonmatrix[curr_idx][j][0] for j in range(5)])
                        if np.sum(probs) > 0:
                                next_idx = np.random.choice(range(5), p=probs/np.sum(probs))
                                # Get the associated return and volatility for this transition
                                _, avg_return, std_return = broonmatrix[curr_idx][next_idx]
                        else:
                                next_idx = np.random.choice(range(5))
                                avg_return, std_return = 0, 0.01  # Default values
                 else:
                        next_idx = np.random.choice(range(5))
                        avg_return, std_return = 0, 0.01  # Default values
                 next_val = next_idx - 2  # Convert back to -2..2
                 extended.append(next_val)
                 returns.append(avg_return)
                 volatilities.append(std_return)
           return extended[1:], returns, volatilities
      
    
    # RSI Value (calculation)
    def calculate_rsi(self, prices, is_crypto):
            if is_crypto: period = 9
            else: period = 14
            pricesnp = np.array(prices)
            deltas = np.diff(pricesnp)
            gains = np.where(deltas > 0, deltas, 0)
            losses = np.where(deltas < 0, -deltas, 0)
            o_av_gain = np.mean(gains[:period])
            o_av_loss = np.mean(losses[:period])
            gains_series = np.zeros_like(prices)
            losses_series = np.zeros_like(prices)
            gains_series[period] = o_av_gain
            losses_series[period] = o_av_loss
            for i in range(period + 1, len(prices)):
                  gains_series[i] = (gains_series[i-1] * (period-1) + gains[i-1]) / period
                  losses_series[i] = (losses_series[i-1] * (period-1) + losses[i-1]) / period
            rs = gains_series / (losses_series + 1e-10)
            rsi = 100 - (100 / (1 + rs))
            return rsi
       
   #Streak (calculation)
    def hotstreakpercbias(self, data, chain_length=234):
    	  longaroon_tally = 0
    	  longaroon = 0
    	  hsperc = 0
    	  hsbias = 0
    	  mean1 = 21
    	  for AO in range(chain_length):
                  dataA = data.iloc[:-AO] if AO > 0 else data
                  longaroon_periods = [5, 6, 6, 7, 8, 9]
                  aroon_num = len(longaroon_periods)
                  aroon_oscillators = [0]*aroon_num
                  for j in range(aroon_num):
                       aroon_period = longaroon_periods[j]
                       mids = (3*dataA['Open'].tail(aroon_period)+4*dataA['Close'].tail(aroon_period))*(1/7)
                       highs = dataA['High'].tail(aroon_period)
                       lows = dataA['Low'].tail(aroon_period)
                       geohighs =(highs*mids)**(1/2)
                       geolows = lows + (mids - (mids*lows)**(1/2))
                       high_series = geohighs
                       low_series = geolows
                      # Check if series are empty before calling argmax/argmin
                       if len(high_series) == 0 or len(low_series) == 0:
                           aroon_oscillators[j] = 0  # Default value when data is missing
                           continue
                       periods_since_high = aroon_period - high_series.values.argmax() - 1
                       periods_since_low = aroon_period - low_series.values.argmin() - 1
                       aroon_up = ((aroon_period - periods_since_high) / aroon_period)*100
                       aroon_down = ((aroon_period - periods_since_low) / aroon_period)*100
                       aroon_oscillators[j] = (aroon_up - aroon_down)
                  mean0 = mean(aroon_oscillators)
                  if AO == 0: longaroon = mean(aroon_oscillators)
                  if AO == 1: longaroonm1 = mean(aroon_oscillators)
                  if mean1 > 17 and (mean1 > mean0): longaroon_tally += 1
                  mean1 = mean0
    	  hsperc = 100*longaroon_tally/chain_length
    	  if longaroon > longaroonm1:
    	  	hsbias = 40*(hsperc/100 + 1.50)*(1.00 - (longaroon+ longaroonm1)/200)
    	  else:
    	  	hsbias = 40*(hsperc/100 + 1.50)*(1.00 + (longaroon+ longaroonm1)/200)
    	  return longaroon, hsperc, hsbias         
    	               
    	               
   #Bullhorse Strength (calculation)
    def compute_multi_ma_macd(self, data, is_crypto, PercMnValA):
         try: 
              if is_crypto: periods = [33, 72, 105, 156, 225] #cryptos
              else: periods = [25, 52, 97, 144, 196] #stocks
              prices = data['Close']
              # Compute Moving Averages
              mas = {}
              for period in periods:
                    mas[period] = prices.rolling(window=period).mean().iloc[-1]
              # Compute MACDs between different MA combinations
              macds = {}
              crossover_count = 0
              Xover_flag = 0
              if is_crypto: #cryptos
                  ma_combos = [(33, 72), (33, 105), (33, 156), (33, 225),
                                              (72, 105), (72, 156), (72, 225),
                                              (105, 156), (105, 225),
                                              (156, 225)]
              else: #stocks
                   ma_combos = [(25, 52), (25, 97), (25, 144), (25, 196),
                                              (52, 97), (52, 144), (52, 196),
                                              (97, 144), (97, 196),
                                              (144, 196)]
              for fast, slow in ma_combos:
                      macd_key = f'{fast}-{slow}'
                      signal_span0 = 4
                      signal_span1 = 9
                      signal_span2 = round(fast*4/13)
                      signal_span3 = round(fast*7/13)
                      fast_ma = prices.ewm(span=fast, adjust=False).mean()
                      slow_ma = prices.ewm(span=slow, adjust=False).mean()
                      # MACD Line
                      macd_line = fast_ma - slow_ma
                      # Signal Line (9-period EMA of MACD)
                      signal_line0 = macd_line.ewm(span=signal_span0, adjust=False).mean()
                      signal_line1 = macd_line.ewm(span=signal_span1, adjust=False).mean()
                      signal_line2 = macd_line.ewm(span=signal_span2, adjust=False).mean()
                      signal_line3 = macd_line.ewm(span=signal_span3, adjust=False).mean()
                      signal_line = (2*signal_line0 + 3*signal_line1 + 1*signal_line2 + 1*signal_line3)/7
                     # Histogram and Crossover
                      histogram = macd_line - signal_line
                      # Count crossovers
                      is_crossover = (macd_line.iloc[-1] > signal_line.iloc[-1])
                      if is_crossover: crossover_count += 1
                      macds[macd_key] = {
                                    'macd_line': macd_line.iloc[-1],
                                    'signal_line': signal_line.iloc[-1],
                                    'histogram': histogram.iloc[-1],
                                    'crossover': is_crossover}
              if min(PercMnValA) >= -3.25: crossover_count += 1; Xover_flag +=1
              if self.longaroon > 40: crossover_count += 2
              if self.hsperc >= 29: crossover_count += 4
              if self. hsbias > 100: crossover_count += 3
              self.Qcrossover = crossover_count
              self.Xover_flag = Xover_flag
              return { 'moving_averages': mas, 'macds': macds}
         except Exception as e:
                 print(f"Multi MA-MACD Calculation Error: {e}")
                 return None   
   	


    #Plot Simulation (Function)
    def plot_monte_carlo(self, hist_data, ticker, backtrack_days=0):
          # Clear previous plots
          self.clear_box_grid() 
          #Mapping Data History Period from Forecast Selection
          self.forecast_period = self.prd_select.get()
          history_prd_map = {'1.5 WK': '1Mo',  '1 MO': '3Mo',  '2 MO': '6Mo', '4 MO': '1Yr', '1.5 YR': '5Yr'}
          history_prd = history_prd_map.get(self.forecast_period)
          #History Period to Day Conversions for Stocks and Cryptos
          chist_conv = {'1Mo': '32', '3Mo': '96', '6Mo': '192', '1Yr': '365', '5Yr': '1825'}
          shist_conv = {'1Mo': '23', '3Mo': '69', '6Mo': '138', '1Yr': '274', '5Yr': '1300'}
          is_crypto = '-USD' in ticker
          if is_crypto: 
              histpd = chist_conv.get(history_prd)
              histpd1wk = 32
          else: 
              histpd = shist_conv.get(history_prd)
              histpd1wk = 23
          self.histprd = int(histpd) + 3
          self.simdays = int(self.histprd) // 3
          self.histprd1wk = int(histpd1wk) + 3
          self.simdays1wk = int(self.histprd1wk) // 3
          if is_crypto:  #Crypto Days Label
          	days_label = f'~ {backtrack_days} days ago' if backtrack_days > 0 else '~ Right Now'    
          else:  #Stock Days Label
               days_label = f'~ {backtrack_days} biz days ago' if backtrack_days > 0 else '~ Right Now'
         # Crypto Tickers and Period Map (display format)
          display_ticker = ticker.replace('-USD', '☆').replace('SVIX', '☼SVIX☼')
          # Historical Data (backtracking)
          if backtrack_days > 0: hist_data = hist_data.iloc[:-backtrack_days]
          # Historical Data (tailing)
          hist_data1 = hist_data.tail(self.histprd)
          l_opens = hist_data['Open']
          opens = hist_data1['Open']
          l_closes = hist_data['Close']
          closes = hist_data1['Close']
          l_mids = (3*l_opens+4*l_closes)/7
          mids = (3*opens+4*closes)/7
          highs = hist_data1['High']
          l_lows = hist_data['Low']
          lows = hist_data1['Low']
          geohighs = (highs*mids)**(1/2)
          geolows = lows + (mids - (mids*lows)**(1/2))
          self.avghistdata1 = (3*opens + 7*(geolows+geohighs)*(1/2) + 14*closes)*(1/24)
          # Run Calculations
          self.allcalculations(hist_data, backtrack_days)
          self.avghistdata1.iloc[-1] = self.current_price
         # Create Figure, Axes, and Dates (for display)
          fig = plt.figure(figsize=(10, 9))
          fig.set_size_inches(10, 9)
         # Set Historical Dates
          historical_dates = hist_data1.index
          last_hist_date = historical_dates[-1]
         # Set Sim Dates
          sim_dates = [last_hist_date + timedelta(days=i) for i in range(self.simulations.shape[1])]
          ax = fig.add_subplot(111)
          # Percentile Zones and Median Projection (calculation data)
          percentiles = [ # Calculated percentiles based on 2/3rd exit zones
                 np.percentile(self.simulations, 0.1, axis=0),
                 np.percentile(self.simulations, 0.66, axis=0), 
                 np.percentile(self.simulations, 6.6, axis=0) ,
                 np.percentile(self.simulations, 28, axis=0) , 
                 np.percentile(self.simulations, 50, axis=0), #median
                 np.percentile(self.simulations, 72 , axis=0),
                 np.percentile(self.simulations, 94.4, axis=0),
                 np.percentile(self.simulations, 99.33, axis=0),  
                 np.percentile(self.simulations, 99.33, axis=0)]  
          median_projection = percentiles[4] #median projection
         # Zone Mins
          self.zonemins = [min(percentiles[3]), min(percentiles[2]), min(percentiles[1]), min(percentiles[0])]
         #Estimated Whale Boosts
          whale_pairs = []
          minboostperc = 7.4 # minimum whale boost percentage for consideration
          up_scan = 5.5 + self.Qcrossover # % above current_price to detect whale boosts
          downscan = 5.5 + self.Qcrossover # % below current_price to detect whale boosts
          whale_sink = 7 - 20*(mean(self.aroon_osc[-4:])/100)*(self.mrsi + self.arsi) # %below buyback level
          boost_drop = self.hsperc # % estimate of sunk lows due to nonwhale movement
          sprd = 1 # number of days per back_period
          back_periods = len(l_lows)//sprd # number of back_periods for data slicing
          self.up_scan = (100+up_scan)/100
          self.downscan = (100-downscan)/100
          max_neg_index = -min(back_periods * sprd, len(l_lows))
          slices = [(i - sprd, i) for i in range(-1, max_neg_index, -sprd)]
          for start, end in slices:
                pos_start = len(l_lows) + start if start < 0 else start
                pos_end = len(l_lows) + end if end < 0 else end
                if pos_start < 0 or pos_end <= 0 or pos_start >= len(l_lows):  continue
                period_lows = l_lows.iloc[pos_start:pos_end] if hasattr(l_lows, 'iloc') else l_lows[pos_start:pos_end]
                if len(period_lows) == 0: continue
                min_value = min(period_lows)
                rel_min_index = list(period_lows).index(min_value)
                abs_min_index = pos_start + rel_min_index
                if abs_min_index >= len(l_mids): continue
                if hasattr(l_mids, 'iloc'): core_mid = l_mids.iloc[abs_min_index]
                else: core_mid = l_mids[abs_min_index]
                if core_mid > 0: w_boost = (100 - boost_drop) * (core_mid - min_value) / core_mid
                whale_pairs.append((min_value * (100 - whale_sink) / 100, w_boost))
          if whale_pairs:
              whale_pairs_sorted = sorted(whale_pairs, key=lambda x: x[0], reverse=True)
              whale_lows = [pair[0] for pair in whale_pairs_sorted if ((pair[0] < self.current_price * self.up_scan) and (pair[0] > self.current_price*self.downscan) and (pair[1] > minboostperc))]
              whale_boosts = [pair[1] for pair in whale_pairs_sorted if ((pair[0] < self.current_price * self.up_scan) and (pair[0] > self.current_price*self.downscan) and (pair[1] > minboostperc))]
              filtered_whale_lows = []
              filtered_whale_boosts = []
              if len(whale_lows) > 0:
                   # Start with the first group
                   current_group_lows = [whale_lows[0]]
                   current_group_boosts = [whale_boosts[0]]
                   # Process remaining prices
                   for i in range(1, len(whale_lows)):
                        # Check if current price is within 2.5% of the previous one
                        if (whale_lows[i-1] - whale_lows[i])/whale_lows[i-1] < 0.025:
                             # Add to current group
                             current_group_lows.append(whale_lows[i])
                             current_group_boosts.append(whale_boosts[i])
                        else:
                            # Save current group and start a new one
                             filtered_whale_lows.append(current_group_lows[-1])  
                             filtered_whale_boosts.append(mean(current_group_boosts))  
                             # Start a new group
                             current_group_lows = [whale_lows[i]]
                             current_group_boosts = [whale_boosts[i]]
                  # Add the last group
                   filtered_whale_lows.append(current_group_lows[-1])
                   filtered_whale_boosts.append(mean(current_group_boosts))
              self.whale_lows = filtered_whale_lows
              self.whale_boosts = filtered_whale_boosts
              wperc = 8; self.whaleprox = ''
              for ref_price in self.whale_lows:
                    lower_bound = ref_price * (1 - 0.3*wperc/100)
                    upper_bound = ref_price * (1 + wperc/100)
                    if lower_bound <= self.current_price <= upper_bound: self.whaleprox = "⥾"
          else: self.whale_lows = []; self.whale_boosts = []; self.whaleprox = ''
          # maxFuture:
          midpercb = np.percentile(self.simulations - self.current_price, 50, axis=0)
          indices = np.arange(len(midpercb))
          indices = np.where(indices == 0, 1, indices)
          mrates = midpercb / indices
          max_index = np.argmax(mrates)
          self.max_index = max_index
          max_future = median_projection[max_index]
          self.max_future = max_future
          max_date = sim_dates[max_index]
          self.fmaxday = (max_date - last_hist_date).days
          # cfuture and csize:
          control_points = np.array([1, 1, 2, 3, 5, 8, 13, 21, 33, 54, 87, 141])
          indices = np.linspace(0, len(control_points), len(median_projection))  
          weights = np.interp(indices, np.arange(len(control_points)), control_points)
          cfuture = np.exp(np.sum(weights * np.log(median_projection)) / np.sum(weights))
          if (cfuture < 0) or (np.isnan(cfuture)): cfuture = 1.11e-9
          self.cfuture = cfuture
          if self.cfuture >= self.spprts[1]: csize = 6
          elif self.cfuture >= self.spprts[9] : csize = 7
          elif self.cfuture >= self.spprts[12] : csize = 8
          elif self.cfuture >= mean(self.spprts[13:20]) : csize = 9
          elif self.cfuture >= self.spprts[21] : csize = 10
          elif self.cfuture >= self.spprts[24] : csize = 9
          elif self.cfuture >= self.spprts[32] : csize = 8
          else: csize = 7
         # Win Potentials:
          self.maxWinPo = self.max_future / self.current_price
          self.maxwinrate = 100*(self.maxWinPo-1)/(max_index+1)
          self.cWinPo = self.cfuture / self.current_price
          # Safe B•Sell:
          ardays = 3
          arn0 = self.aroon_osc[-1]
          arn1 = self.aroon_osc[-2]
          arn2 = mean(self.aroon_osc[-(ardays):-1])
          arn3 = mean(self.aroon_osc[-(ardays+1):-1])
          maxss = (self.max_future-self.current_price)/(max_index+.0000001) + self.current_price
          if (self.aroon_osc[-1]>-38) and ((arn0>arn1) or (arn0>arn2) or (arn0>arn3)) and (self.pivhigh > self.current_price): self.safe_sell = (1/5)*(4*maxss + self.pivhigh); ssind = f"{format_value(self.safe_sell)}ɓ"; self.ssind = ssind
          elif (self.aroon_osc[-1] > -66)  and ((arn0>arn1) or (arn0>arn2) or (arn0>arn3)) and (self.pivhigh > self.current_price): self.safe_sell = min(self.pivhigh, maxss); ssind = f"{format_value(self.safe_sell)}ɓ"; self.ssind = ssind
          elif self.cfuture > 0.97*self.current_price: self.safe_sell = self.current_price; ssind = f"{format_value(self.safe_sell)}ɓ  Dip"; self.ssind = 'Dip ⭞'
          else: self.safe_sell = self.current_price; ssind = f"{format_value(self.safe_sell)}ɓ  Drop"; self.ssind = 'Drop ￬'
          # Set Min and Max Y-Values
          Ymin = 0; Ymax = max(self.ENVmax*1.1, self.spprts[0]*1.20, cfuture)
          # Window Mean:
          hist_mean = np.exp(np.mean(np.log(self.avghistdata1)))
          wMsize = 4
          #AllColors:
          color_upfut = [ '#B968D0',  '#C000AA', '#BB77BBFF' ]
          color_dnfut = ['#EA5555', '#FF0099', '#AD258AFF']
          if self.cfuture >= self.current_price: 
              self.precfut = "ĉ"; colfut1 = color_upfut[0]; colfut2 = color_upfut[1]; colfut3 = color_upfut[2]
          else: self.precfut = "č"; colfut1 = color_dnfut[0]; colfut2 = color_dnfut[1]; colfut3 = color_dnfut[2]
          perczone_colors = ['#FFFFFF', '#FF000046', '#FF000092', colfut2, colfut2, 
                                              '#0000FF92', '#0000FF46', '#0000FF23', '#0000FF11']
          support_colors = ['#0000FF49', '#0000FF64', '#0000FF9B', 
                                                                  '#AA11AAD0', 
                                           '#FF00009B', '#FF000064', '#FF000049']
         # Percentile Zones (plot):
          for i in range(8):  # 8 total zones (4 under + 4 over median)
                lower_idx = i; upper_idx = i + 1; color = perczone_colors[i]
                upper = np.asarray(percentiles[upper_idx]); upper_capped = upper.copy()
                lower = np.asarray(percentiles[lower_idx]); lower_capped = lower.copy()
                for j in range(len(upper)):
                     upper_capped[j] = max(min(upper[j], Ymax), Ymin)
                     lower_capped[j] = max(min(lower[j], Ymax), Ymin)
                ax.fill_between(sim_dates, lower_capped, upper_capped, color=color, zorder=1)
                if i == 4: self.medproj = lower_capped
         # Median Projection (plot):
          ax.plot(sim_dates, self.medproj, color=colfut3, linestyle='-', 
          linewidth=4, zorder = 5, label=f"Mdn Projection")
          # cFuture (plot):
          ax.axhline(y=self.cfuture, color=colfut1, linestyle = ':', linewidth=csize, zorder =5,
                               label=f'{self.forecast_period} {self.precfut}Future {format_value(self.cfuture)}ɓ')
          # Safe BSell Line (plot):
          ax.axhline(y=self.safe_sell, color='#66AA33', linestyle='--', linewidth=csize - 4, zorder = 5,
                                  label=f'Safe B•Sell ({ssind})')                      
          # Present Value (plot):
          ax.axhline(y=self.current_price, color='#7799D6', linestyle=':', linewidth=csize, zorder = 4, label=f'Present {format_value(self.current_price)}ɓ')
          # Support Lines (plots):
          for k in range(0, 34):
          	    if self.spprts[k] > 0:
          	        lwidth = 2
          	        if (k in [1, 6, 9,    11, 12, 13,    20, 21, 22,   24, 27, 32]):  lstyle = '--' # Fib Spprts
          	        elif k in   [14,  19]: lwidth = 2; lstyle = '-.' # Border Spprts
          	        else: lstyle = ':' # Sqntl Spprts
          	        if k < 6: supclr = support_colors[0]
          	        elif k < 10 : supclr = support_colors[1]
          	        elif k <14: supclr = support_colors[2]
          	        elif k < 20: supclr = support_colors[3]
          	        elif k < 24: supclr = support_colors[4]
          	        elif k < 28: supclr = support_colors[5]
          	        elif k < 34: supclr = support_colors[6]
          	        ax.axhline(y=self.spprts[k], color= supclr, linestyle = lstyle, linewidth = lwidth, zorder = 1)
         # Piv Lines (plots):
          ppj = ['Piv⚀', 'Piv⚁', 'Piv⚂']
          for j in range(0,3):
                 if self.current_price > self.pivots[j]:
                     ax.axhline(y=self.pivots[j], color='#333333', linestyle='-', linewidth = 2, 
                     zorder =5, label=f'{ppj[j]} {format_value(self.pivots[j])}ɓ')
         # Envelope (plot):
          envColor = '#BB00BBAA'
          for boundary in [self.UpperB, self.LowerB]:
                min_length = min(len(historical_dates), len(boundary))
                diff = len(historical_dates) - len(boundary)
                if diff <= 0:  ax.plot(historical_dates, boundary[:min_length], color = envColor, linewidth=4, zorder=5)
                else:  ax.plot(historical_dates[diff:], boundary, color = envColor, linewidth=4, zorder=5)
          # Historical Prices (plots):
          # High and Low Prices -
          ax.plot(historical_dates[0:-1], highs[0:-1], color='#775588', linewidth=2, zorder = 5)
          ax.plot(historical_dates[0:-1], lows[0:-1], color='#775588', linewidth=2, zorder = 5)
          # Daily Average Prices -
          ax.plot(historical_dates, self.avghistdata1, color='black', label='Historical Price', linewidth=4, zorder = 5)
          # Window Mean (plot):
          ax.axhline(y=hist_mean, color='#E8C04A', linestyle=':', linewidth=wMsize, zorder = 2,
                              label=f'wndMean: {format_value(hist_mean)}ɓ')             
          # Main Plot (format):
          # title -
          title_prefix = f'{self.forecast_period}  '
          title_suffix = f' {days_label}'
          date_fix = f'({history_prd} History + {self.forecast_period} Forecast)'
          date_fix = date_fix.replace("YR", "Yr").replace("MO", "Mo").replace("WK", "Wk")
          ax.set_title(f'{title_prefix}Forecast ({display_ticker}{title_suffix})', fontsize=30)
          # x-axis -
          ax.set_xlabel(f'{date_fix} [Dates]', fontsize=24)
          fig.autofmt_xdate()
          ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
          # y-axis -
          ax.set_ylabel('Price [ɓucks]', fontsize=24)
          price_formatter = FuncFormatter(lambda x, p: format_value(x))
          ax.yaxis.set_major_formatter(price_formatter)
          ax.yaxis.set_major_locator(plt.MaxNLocator(7))
          # legend -
          ax.legend(fontsize=17, loc = 3, facecolor = 'lightgray', framealpha = 0.88)
          plt.tight_layout()
          # Canvas (display):
          canvas = FigureCanvasTkAgg(fig, master=self.box_grid)
          canvas.draw()
          canvas_widget = canvas.get_tk_widget()
          canvas_widget.grid(row=0, column=0, sticky='news')
             
           
   #Update Indicator Labels Display (Function)
    def update_indicator_label(self, hist_data):
            try:  #SetIndicator1:
                    # Suffixes -
                    SupSuffixes =   ['Ⓞ','Ⓝ','Ⓜ','Ⓛ','Ⓚ','Ⓙ','Ⓘ',
                                               'Ⓗ','Ⓖ','Ⓕ','Ⓔ','Ⓓ','Ⓒ','Ⓑ','Ⓐ',
                                               '➄','➃', '➂', '➁', '➀',  'ⓐ','ⓑ','ⓒ',
                                             'ⓓ','ⓔ','ⓕ','ⓖ','ⓗ','ⓘ','ⓙ','ⓚ','ⓛ']
                    PivSuffixes =                  ['⚀', '⚁', '⚂', '⚃']
                    WhlSuffixes = ['Ⓐ','Ⓑ','Ⓒ','Ⓓ','Ⓔ','Ⓕ','Ⓖ','Ⓗ', 'Ⓘ','Ⓙ',
                                               'Ⓚ','Ⓛ','Ⓜ','Ⓝ', 'Ⓞ', 'Ⓟ','Ⓠ','Ⓡ','Ⓢ','Ⓣ']
                    MinSuffixes =                 ['⭘','ᨖ','ꕢ', 'ꕤ']
                    # Envelope -
                    if self.curEnv > self.mnEnv: envpref = " ￪ ƒivs"
                    elif self.curEnv == self.mnEnv: envpref = '⇶ƒivs'
                    elif self.curEnv < self.mnEnv: envpref = " ￬ ƒivs"
                    # Åroons -
                    Osc_text = ' '.join([f'{Aosc:.0f}' for Aosc in self.aroon_osc])
                    # Whale Percentages -
                    boost_chunks = []
                    bchnk = 7
                    for i in range(0, len(self.whale_boosts), bchnk):
                          chunk = self.whale_boosts[i:i+bchnk]
                          suffix_chunk = WhlSuffixes[i:i+bchnk]
                          chunk_text = ', '.join([f'{suffix}+{boost:.1f}%' for boost, suffix in zip(chunk, suffix_chunk)])
                          boost_chunks.append(chunk_text)
                    Boost_text = '\n'.join(boost_chunks)
                    # All Combined Support Levels -
                    combined_supports = []
                    for idx, level in enumerate(self.spprts):
                          if idx < len(SupSuffixes) and (0 < level <= self.current_price):
                             label = f"sup{SupSuffixes[idx]}"
                             combined_supports.append((label, level))
                    for idx, level in enumerate(self.zonemins):
                           if idx < len(MinSuffixes) and (max(0.5*self.spprts[-1], 0) < level < self.current_price):
                              label = f"min{MinSuffixes[idx]}"
                              combined_supports.append((label, level))
                    for idx, level in enumerate(self.pivots):
                           if idx < len(PivSuffixes) and (0 < level < self.current_price):
                              label = f"piv{PivSuffixes[idx]}"
                              combined_supports.append((label, level))
                    for idx, level in enumerate(self.whale_lows):
                           if idx < len(WhlSuffixes) and (0 < level < self.current_price*self.up_scan):
                              label = f"ฬኽℓ{WhlSuffixes[idx]}"
                              combined_supports.append((label, level))
                    combined_supports.sort(key=lambda x: x[1], reverse=True)
                    ITEMS_PER_LINE = 5
                    support_lines = []
                    for i in range(0, len(combined_supports), ITEMS_PER_LINE):
                          chunk = combined_supports[i:i + ITEMS_PER_LINE]
                          line = ',  '.join([f"{label}:{format_value(level)}ɓ" 
                                          for label, level in chunk])
                          support_lines.append(line)
                    support_text = '\n'.join(support_lines)
                    # News Sentiment
                    current_days = int(self.backtrack_days.get())
                    if  (news_sentiment ==  "---") or (current_days !=0):
                        S_news = ""
                    else: S_news = f"[[ News Sentiment:  {news_sentiment} ]]"
                    #SetIndicator1Text:
                    indicator1_text = (
                       f"\n\n  [ ENV || ARNs || RSIs ] => [ {self.mnEnv:.0f}:{self.curEnv:.0f}{envpref} || ({Osc_text})% {self.fc} ({self.arsi:.2f}, {self.mrsi:.2f})] \n{S_news}\n"
                       f"《Pres: {format_value(self.current_price)}ɓ | SafeB•Sell:  {self.ssind} | {self.precfut}Fut: {self.forecast_period} ~{format_value(self.cfuture)}ɓ | {self.cWinPo:.2f}x》\n"
                       f" \n ฬኽɑℓꬲ Boosts: \n  {Boost_text}\n"
                       f"\n Support Levels:\n [{support_text}]\n\n")
                   #SetIndicator2:
                    indicator2_text = ""
                   # Week Means -
                    mnval_text = ', '.join([f'{pval:.0f}%' for pval in self.PercMnValA])
                    # Streaks -
                    if self.hsperc > 30.00: streak = "FireStreak➠"
                    elif self.hsperc > 26.25: streak = "HotStreak=>"
                    elif self.hsperc > 19.75: streak = "ColdStreak⭆"
                    else: streak = "GlacierStreak ≡] "
                    if hasattr(self, 'moving_averages') and hasattr(self, 'macds'):
                         # MA's -
                          ma_text = ("\n Moving Averages:   \n"
                                                f'3dMA:  {format_value(self.MnValA[-1])}ɓ    ')
                          for period, value in self.moving_averages.items():
                                fv = format_value(value)
                                if fv != "0" and period not in [97, 105]: 
                                      ma_text += f"  {period}dMA: {fv}ɓ   "
                                elif fv!= "0" and period in [97, 105]: 
                                      ma_text += f"\n{period}dMA: {fv}ɓ    "
                         # MACD's -
                          macd_text = (f"\n\nVertWake    [[[{self.Qcrossover}:20]]]  | {streak}({self.hsperc:.0f}:{self.hsbias:.0f})%| "
                                                   f"|WkMeans  {'+' if self.Xover_flag == 1 else '–'} |\n")
                          for combo, macd_info in self.macds.items():
                                if combo in ['52-97', '72-105', '97-144', '105-156', '144-196', '156-225']:
                                	macd_text +=(f"\n"
                                	f"|{combo} MACD {'+' if macd_info['crossover'] else '–'} |")
                                else:
                                    macd_text += (f"| {combo} MACD {'+' if macd_info['crossover'] else '–'} |")
                         #SetIndicator2Text:
                          indicator2_text += f"\n  %WkMeans: [{mnval_text}]   \n " + ma_text  + macd_text + "\n\n" 
                   #UpdateIndicatorLabels:
                    self.lbl_indicators1.config(text=indicator1_text)
                    self.lbl_indicators2.config(text=indicator2_text)
                    self.determine_friction()
            except Exception as e:
                    self.lbl_indicators1.config(text="---")
                    self.lbl_indicators2.config(text="---")
   
   	
#Main Loop (Function)
def main():
    root = Tk()
    app = MonteCarloSimulator(root)
    root.mainloop()
if __name__ == "__main__":
    main()